def write_input(pos_file_path, dvm_input_dict = None):
    '''
    Description:
    Write the *.input file for a DVM calculation based on the atom position file (*.incar or POSCAR format)
    Currently, for the pos_file_path, only the POSCAR format is supported. In the future the *.incar will also be surpported and the automatic file format recognition should be used.
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    dvm_input_dict: the dictionary which contains the input parameters of the *.input file. If dvm_input_dict = None, then the default value of the parameters in the *.input file will be used
    '''
    args_dict = locals()
    import os
    import numpy as np
    from .. import funcs
    from .. import default_params
    from ..vasp import vasp_read
    from . import dvm_default
    from . import dvm_help
 
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])

    dvm_help_dict = dvm_help.dvm_help()

    # set the predefined value of parameters in the .input file
    # frozeninfo
    dvm_frozeninfo_dict = dvm_default.input_frozeninfo()

    dvm_input_header ='''#------------------------------------------------------------------------------- 
#
#  This is the master input file of DVDAC
#  
#  Note the policy is one line for one keyword only. If one line is 
#  not enough for a keyword, you can use "&" at the end of the line 
#  to continue the input. "&" must be at the end will take effect!
#
#  Keyword can be written at any place in the file. If there are more 
#  than two, only the first one will be read.
#
#  Use "#" and "!" for comment. Any thing after them will be ignored.   
#
#------------------------------------------------------------------------------- 



'''

    # atom position file
    pos_file_path = os.path.abspath(pos_file_path)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)
    if funcs.file_status(pos_file_path) != 1:
        quit()

    # extract the job name
    file_list = os.listdir(workdir)
    for i_file in file_list:
        if 'incar' in i_file:
            job_name = i_file[0:-6]

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
            n_atoms = poscar_dict['n_atoms']

    dvm_input_default_dict = dvm_default.input_default()
    if dvm_input_dict == None:
        dvm_input_dict = dvm_input_default_dict
        dvm_input_dict['jobid'] = '\"' + ''.join(elmt_species_arr) + '. Generated by matsdp\"'
        dvm_input_dict['nbasis'] = len(elmt_species_arr)
        dvm_input_dict['natom'] = n_atoms
        # frozeninfo
        frozeninfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    &   ! ' + i_species + '\n' + ' ' * 17
            else:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    ! ' + i_species 
        dvm_input_dict['frozeninfo'] = frozeninfo
        # grid3dinfo
        grid3dinfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                grid3dinfo = grid3dinfo + dvm_input_dict['grid3dinfo'] + '     &' + '\n' + ' ' * 17
            else:
                grid3dinfo = grid3dinfo + dvm_input_dict['grid3dinfo']
        dvm_input_dict['grid3dinfo'] = grid3dinfo
        
    else:
        temp_dict = dvm_input_default_dict.copy()
        temp_dict.update(dvm_input_dict)
        dvm_input_dict = temp_dict
        
    input_str = ''
    input_str = input_str + dvm_input_header
    for item in range(0,len(dvm_input_dict)):
        input_key = list(dvm_input_dict.keys())[item]
        input_key = input_key + ' ' * (13 - len(input_key))
        input_value = list(dvm_input_dict.values())[item]
        input_value_str = str(input_value)
        if len(input_value_str) >= 13:
            input_value_str = input_value_str + ' ' * 4
        else:
            input_value_str = input_value_str + ' ' * (13 - len(input_value_str))
        input_help_value = list(dvm_help_dict.values())[item]
        input_str = input_str + '  '+ input_key + '= ' + input_value_str + ' ' + str(input_help_value) + '\n'
        if input_key.strip() == 'ifdebug':
            input_str = input_str + '\n\n\n'
        if input_key.strip() == 'frozeninfo':
            input_str = input_str + '\n'
        if input_key.strip() == 'grid3dinfo':
            input_str = input_str + '\n'

    dest_input_file_path = os.path.join(workdir, job_name + '.input')
    with open(dest_input_file_path,'w') as f_dest_input:
        f_dest_input.write(input_str)
    funcs.write_log(
        logfile,
        'dvm_write.write_input(\n' + 
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    dvm_input_dict = ' + str(None) + ')\n' +
        '#######################\n'
        )
    return input_str

def write_ind(pos_file_path, elmt_ind_file_dir):
    '''
    Description:
    write the IND.DAT file for a DVM calculation
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    elmt_ind_file_dir: the directory which contains the element IND.DAT files. The element IND.DAT files if the file with IND.DAT information of each element
    '''
    args_dict = locals()
    import os
    from .. import funcs
    from ..vasp import vasp_read
    from .. import default_params
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])

    # atom position file and element potential file
    pos_file_path = os.path.abspath(pos_file_path)
    elmt_ind_file_dir = os.path.abspath(elmt_ind_file_dir)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
        # concatenate IND.DAT files of elements
        ind_file_path = os.path.join(os.path.join(workdir, 'IND.DAT'))
        ind_file_str = ''
        for i_elmt_name in elmt_species_arr:
            elmt_ind_file = 'IND_' + i_elmt_name + '.DAT'
            elmt_ind_file_path = os.path.join(elmt_ind_file_dir, elmt_ind_file)
            with open(elmt_ind_file_path, 'r') as f_elmt_ind:
                lines = f_elmt_ind.readlines()
                for i_line in lines:
                    ind_file_str = ind_file_str + i_line
            ind_file_str = ind_file_str.strip('\n') + '\n0.\n'
        ind_file_str = ind_file_str + ' -1 THAT\'S ALL.'
        with open(ind_file_path, 'w') as f_ind:
            f_ind.write(ind_file_str)
    funcs.write_log(
        logfile,
        'dvm_write.write_ind(\n' +
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    elmt_ind_file_dir = ' + 'r\'' + str(elmt_ind_file_dir) + '\')\n' +
        '########################\n'
        )
    return 0

def write_ie(dvm_otput_file_path):
    '''
    Interatomic energy between the atoms and their nearest neighbor atoms.
    This module has been tested for the source_23oct05 version of the DVM program
    dvm_otput_file_path: the *.otput file of the DVM output
    '''
    args_dict = locals()
    import os
    import numpy as np
    from .. import funcs
    from .. import convert
    from ..vasp import vasp_read
    from ..vasp import vasp_analyze
    from . import dvm_read
    from .. import default_params

    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])
    funcs.mkdir(output_dir)

    dvm_otput_file_path = os.path.abspath(dvm_otput_file_path)
    # designate the working directory
    workdir, dvm_otput_file = funcs.file_path_name(dvm_otput_file_path)

    dvm_incar_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '.incar')
    convert.dvmincar2poscar(dvm_incar_file_path)
    dvmincar2poscar_poscar_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_dvmincar2poscar.vasp')
    poscar_dict = vasp_read.read_poscar(dvmincar2poscar_poscar_file_path)
    atom_name_list = poscar_dict['atomname_list']
    atom_indx_arr = poscar_dict['atom_indx_arr'] 
    n_atoms = poscar_dict['n_atoms']
    added_atom_data_arr = poscar_dict['added_atom_data']
    dvm_otput_dict = dvm_read.read_otput(dvm_otput_file_path)

    ie_au_arr = None
    ie_au_up_arr = None
    ie_au_dw_arr = None
    if dvm_otput_dict['spin'] == 0:
        ie_au_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_arr[i_atom, j_atom] = dvm_otput_dict['ie_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
    if dvm_otput_dict['spin'] == 1:
        ie_au_up_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_up_arr.shape = n_atoms, n_atoms
        ie_au_dw_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_dw_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_up_arr[i_atom, j_atom] = dvm_otput_dict['ie_up_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
                ie_au_dw_arr[i_atom, j_atom] = dvm_otput_dict['ie_dw_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]

    # the output indices based on the atom names
    # write the data into files
    ie_au_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_au_all_atoms.txt')
    ie_ev_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_ev_all_atoms.txt')
    ie_au_file_str = ''
    ie_ev_file_str = ''
    
    for i_atom in range(0, n_atoms):
        i_atom_str = atom_name_list[i_atom] + ' (' + str(added_atom_data_arr[i_atom, 3]) + ')'
        atom_name_str = ', '.join([str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')' + ' ' * (13 - len(str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')')) for x in atom_name_list]) + '\n'

        if dvm_otput_dict['spin'] == 0:
            temp_au_arr = ie_au_arr[i_atom,:]
            temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
            ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
            ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
            ie_au_file_str = ie_au_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                ie_au_str
                )
            ie_ev_file_str = ie_ev_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                ie_ev_str
                )
        if dvm_otput_dict['spin'] == 1:
            temp_au_up_arr = ie_au_up_arr[i_atom,:]
            temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
            temp_au_dw_arr = ie_au_dw_arr[i_atom,:]
            temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
            ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
            ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
            ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
            ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
            ie_au_file_str = ie_au_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                ie_au_up_str +
                ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                ie_au_dw_str
                )
            ie_ev_file_str = ie_ev_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                ie_ev_up_str +
                ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                ie_ev_dw_str
                )
    with open(ie_au_file_path, 'w') as f_ie_au, open(ie_ev_file_path, 'w') as f_ie_ev:
        f_ie_au.write(ie_au_file_str)
        f_ie_ev.write(ie_ev_file_str)


    # the output indices based on the DVM atom indices
    # write the data into files
    ie_au_dvm_indx_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_au_all_atoms_dvm_index.txt')
    ie_ev_dvm_indx_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_ev_all_atoms_dvm_index.txt')
    ie_au_dvm_indx_file_str = ''
    ie_ev_dvm_indx_file_str = ''
    for i_dvm_atom_indx in range(1, n_atoms + 1):
        #i_atom = int(list(added_atom_data_arr[:, 3]).index(str(i_dvm_atom_indx)))
        i_atom = int(np.argwhere(added_atom_data_arr[:, 3] == str(i_dvm_atom_indx)))
        i_dvm_indx_str = str(i_dvm_atom_indx) + ' (' + atom_name_list[i_atom] + ')'
        dvm_atom_indx_str = ', '.join([str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')' + ' ' * (13 - len(str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')')) for x in list(range(1, n_atoms + 1))]) + '\n'

        if dvm_otput_dict['spin'] == 0:
            temp_au_arr = dvm_otput_dict['ie_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
            ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
            ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
            ie_au_dvm_indx_file_str = ie_au_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                ie_au_str
                )
            ie_ev_dvm_indx_file_str = ie_ev_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                ie_ev_str
                )
        if dvm_otput_dict['spin'] == 1:
            temp_au_up_arr = dvm_otput_dict['ie_up_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
            temp_au_dw_arr = dvm_otput_dict['ie_dw_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
            ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
            ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
            ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
            ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
            ie_au_dvm_indx_file_str = ie_au_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                ie_au_up_str +
                ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                ie_au_dw_str
                )
            ie_ev_dvm_indx_file_str = ie_ev_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                ie_ev_up_str +
                ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                ie_ev_dw_str
                )
    with open(ie_au_dvm_indx_file_path, 'w') as f_ie_au_dvm_indx, open(ie_ev_dvm_indx_file_path, 'w') as f_ie_ev_dvm_indx:
        f_ie_au_dvm_indx.write(ie_au_dvm_indx_file_str)
        f_ie_ev_dvm_indx.write(ie_ev_dvm_indx_file_str)

    funcs.write_log(
        logfile,
        'dvm_write.write_ie(\n' + 
        '    dvm_otput_file_path = ' + 'r\'' + str(dvm_otput_file_path) + '\')\n' +
        '#######################\n'
        )
    return ie_au_arr, ie_au_up_arr, ie_au_dw_arr

def write_tex_ie_nn(ie_nn_file_path):
    '''
    write the .tex file of the IE result.
    the spin restricted and spin polarized situations are considered
    ie_nn_file_path: the path for the IE result, it can either be *_ie_ev_nn.txt or *_ie_eu_nn.txt
    '''
    args_dict = locals()
    import os
    from .. import funcs
    from . import dvm_default
    from .. import default_params

    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    ie_nn_file_path = os.path.abspath(ie_nn_file_path)
    workdir, ie_nn_file = funcs.file_path_name(ie_nn_file_path)
    if funcs.file_status(ie_nn_file_path) != 1:
        quit()
    with open(ie_nn_file_path, 'r') as f:
        lines = f.readlines()
        temp = funcs.split_line(lines[1],',')[0]
        if 'up' in temp:
            # spin polarized
            spin = 1
        else:
            # spin restricted
            spin = 0
        if 'eV' in temp:
            unit_tex_str = 'eV'
            unit_file_str = 'ev'
        elif 'a.u.' in temp:
            unit_tex_str = 'a.u.'
            unit_file_str = 'au'
    ie_nn_tex_file_path = os.path.join(workdir, 'ie_nn_' + unit_file_str + '.tex')
    ie_nn_tex_str = ''
    ie_nn_tex_str = ie_nn_tex_str + (
        r'\documentclass[12pt]{article}' + '\n' +
        r'\usepackage{hyperref}' + '\n' +
        r'\usepackage{longtable}' + '\n' +
        r'\title{Interatomic energy of the nearest neighbor atoms}' + '\n' +
        r'\date{}' + '\n' +
        r'\author{}' + '\n' +
        r'\begin{document}' + '\n' +
        r'\maketitle' + '\n' +
        r'\section{Interatomic energy}' + '\n')
    if spin == 0:
        ie_nn_tex_str = ie_nn_tex_str + (
        r'\begin{longtable}{lll}' + '\n' +
        r'\caption{IE (' + unit_tex_str + r')}\\' + '\n' +
        r'\hline' + '\n' +
        r'atom (i) & atom (j) & IE (' + unit_tex_str + r') \\' + '\n' +
        r'\hline' + '\n')
    elif spin == 1:
        ie_nn_tex_str = ie_nn_tex_str + (
        r'\begin{longtable}{llll}' + '\n' +
        r'\caption{IE (' + unit_tex_str + r')}\\' + '\n' +
        r'\hline\n' +
        r'atom (i) & atom (j) & IE (' + unit_tex_str + ')-up & IE (' + unit_tex_str + r')-dw \\' + '\n' +
        r'\hline' + '\n')
        
    with open(ie_nn_file_path, 'r') as f:
        lines = f.readlines()
    for i_line in range(0, len(lines)):
        if spin == 0 and i_line%2 == 0:
            num_col = len(funcs.split_line(lines[i_line],','))
            i_atom_name = str(funcs.split_line(lines[i_line],',')[0])
            j_atom_name_list = [str(x) for x in funcs.split_line(lines[i_line],',')[1:]]
            ie_list = [float(x) for x in funcs.split_line(lines[i_line + 1],',')[1:]]
            for indx in range(0, len(j_atom_name_list)):
                ie_nn_tex_str = ie_nn_tex_str + (
                    i_atom_name + ' ' * (13 - len(i_atom_name)) + '&' +
                    j_atom_name_list[indx] + ' ' * (13 - len(j_atom_name_list[indx])) + '&' +
                    '{:.4f}'.format(ie_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_list[indx]))) + r'\\' + '\n')
        elif spin == 1 and i_line%3 == 0:
            num_col = len(funcs.split_line(lines[i_line],','))
            i_atom_name = str(funcs.split_line(lines[i_line],',')[0])
            j_atom_name_list = [str(x) for x in funcs.split_line(lines[i_line],',')[1:]]
            ie_up_list = [float(x) for x in funcs.split_line(lines[i_line + 1],',')[1:]]
            ie_dw_list = [float(x) for x in funcs.split_line(lines[i_line + 2],',')[1:]]
            for indx in range(0, len(j_atom_name_list)):
                ie_nn_tex_str = ie_nn_tex_str + (
                    i_atom_name + ' ' * (13 - len(i_atom_name)) + '&' +
                    j_atom_name_list[indx] + ' ' * (13 - len(j_atom_name_list[indx])) + '&' +
                    '{:.4f}'.format(ie_up_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_up_list[indx]))) + '&' +
                    '{:.4f}'.format(ie_dw_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_dw_list[indx]))) + r'\\' + '\n')
    ie_nn_tex_str = ie_nn_tex_str + (
        r'\hline' + '\n' +
        r'\end{longtable}' + '\n' +
        r'\end{document}')
    with open(ie_nn_tex_file_path, 'w') as f_tex:
        f_tex.write(ie_nn_tex_str)
    return 0

def write_input(pos_file_path, dvm_input_dict = None):
    '''
    Description:
    Write the *.input file for a DVM calculation based on the atom position file (*.incar or POSCAR format)
    Currently, for the pos_file_path, only the POSCAR format is supported. In the future the *.incar will also be surpported and the automatic file format recognition should be used.
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    dvm_input_dict: the dictionary which contains the input parameters of the *.input file. If dvm_input_dict = None, then the default value of the parameters in the *.input file will be used
    '''
    import os
    import numpy as np
    from .. import funcs
    from .. import default_params
    from ..vasp import vasp_read
    from . import dvm_default
    from . import dvm_help
 
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])

    dvm_help_dict = dvm_help.dvm_help()

    # set the predefined value of parameters in the .input file
    # frozeninfo
    dvm_frozeninfo_dict = dvm_default.input_frozeninfo()

    dvm_input_header ='''#------------------------------------------------------------------------------- 
#
#  This is the master input file of DVDAC
#  
#  Note the policy is one line for one keyword only. If one line is 
#  not enough for a keyword, you can use "&" at the end of the line 
#  to continue the input. "&" must be at the end will take effect!
#
#  Keyword can be written at any place in the file. If there are more 
#  than two, only the first one will be read.
#
#  Use "#" and "!" for comment. Any thing after them will be ignored.   
#
#------------------------------------------------------------------------------- 



'''

    # atom position file
    pos_file_path = os.path.abspath(pos_file_path)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)
    if funcs.file_status(pos_file_path) != 1:
        quit()

    # extract the job name
    file_list = os.listdir(workdir)
    for i_file in file_list:
        if 'incar' in i_file:
            job_name = i_file[0:-6]

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
            n_atoms = poscar_dict['n_atoms']

    dvm_input_default_dict = dvm_default.input_default()
    if dvm_input_dict == None:
        dvm_input_dict = dvm_input_default_dict
        dvm_input_dict['jobid'] = '\"' + ''.join(elmt_species_arr) + '. Generated by matsdp\"'
        dvm_input_dict['nbasis'] = len(elmt_species_arr)
        dvm_input_dict['natom'] = n_atoms
        # frozeninfo
        frozeninfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    &   ! ' + i_species + '\n' + ' ' * 17
            else:
                frozeninfo = frozeninfo + dvm_frozeninfo_dict[i_species] + '    ! ' + i_species 
        dvm_input_dict['frozeninfo'] = frozeninfo
        # grid3dinfo
        grid3dinfo = ''
        for indx in range(0,len(elmt_species_arr)):
            i_species = elmt_species_arr[indx]
            if indx < len(elmt_species_arr) - 1:
                grid3dinfo = grid3dinfo + dvm_input_dict['grid3dinfo'] + '     &' + '\n' + ' ' * 17
            else:
                grid3dinfo = grid3dinfo + dvm_input_dict['grid3dinfo']
        dvm_input_dict['grid3dinfo'] = grid3dinfo
        
    else:
        temp_dict = dvm_input_default_dict.copy()
        temp_dict.update(dvm_input_dict)
        dvm_input_dict = temp_dict
        
    input_str = ''
    input_str = input_str + dvm_input_header
    for item in range(0,len(dvm_input_dict)):
        input_key = list(dvm_input_dict.keys())[item]
        input_key = input_key + ' ' * (13 - len(input_key))
        input_value = list(dvm_input_dict.values())[item]
        input_value_str = str(input_value)
        if len(input_value_str) >= 13:
            input_value_str = input_value_str + ' ' * 4
        else:
            input_value_str = input_value_str + ' ' * (13 - len(input_value_str))
        input_help_value = list(dvm_help_dict.values())[item]
        input_str = input_str + '  '+ input_key + '= ' + input_value_str + ' ' + str(input_help_value) + '\n'
        if input_key.strip() == 'ifdebug':
            input_str = input_str + '\n\n\n'
        if input_key.strip() == 'frozeninfo':
            input_str = input_str + '\n'
        if input_key.strip() == 'grid3dinfo':
            input_str = input_str + '\n'

    dest_input_file_path = os.path.join(workdir, job_name + '.input')
    with open(dest_input_file_path,'w') as f_dest_input:
        f_dest_input.write(input_str)
    funcs.write_log(
        logfile,
        'dvm_write.write_input(\n' + 
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    dvm_input_dict = ' + str(None) + ')\n' +
        '#######################\n'
        )
    return input_str

def write_ind(pos_file_path, elmt_ind_file_dir):
    '''
    Description:
    write the IND.DAT file for a DVM calculation
    pos_file_path: the file path for the file which contains the atom coordinates, now the POSCAR file is supported.
    elmt_ind_file_dir: the directory which contains the element IND.DAT files. The element IND.DAT files if the file with IND.DAT information of each element
    '''
    import os
    from .. import funcs
    from ..vasp import vasp_read
    from .. import default_params
    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])

    # atom position file and element potential file
    pos_file_path = os.path.abspath(pos_file_path)
    elmt_ind_file_dir = os.path.abspath(elmt_ind_file_dir)
    # designate the working directory
    workdir, pos_file = funcs.file_path_name(pos_file_path)

    # recognize the type of the atom position file (in the future the automatic file type recognition shoud be incorprated)
    #pos_file_type = 'dvm_incar'
    pos_file_type = 'POSCAR'

    if pos_file_type == 'POSCAR':
        poscar_dict = vasp_read.read_poscar(pos_file_path)
        with open(pos_file_path, 'r') as f_poscar:
            lines = f_poscar.readlines()
            elmt_species_arr = poscar_dict['elmt_species_arr']
        # concatenate IND.DAT files of elements
        ind_file_path = os.path.join(os.path.join(workdir, 'IND.DAT'))
        ind_file_str = ''
        for i_elmt_name in elmt_species_arr:
            elmt_ind_file = 'IND_' + i_elmt_name + '.DAT'
            elmt_ind_file_path = os.path.join(elmt_ind_file_dir, elmt_ind_file)
            with open(elmt_ind_file_path, 'r') as f_elmt_ind:
                lines = f_elmt_ind.readlines()
                for i_line in lines:
                    ind_file_str = ind_file_str + i_line
            ind_file_str = ind_file_str.strip('\n') + '\n0.\n'
        ind_file_str = ind_file_str + ' -1 THAT\'S ALL.'
        with open(ind_file_path, 'w') as f_ind:
            f_ind.write(ind_file_str)
    funcs.write_log(
        logfile,
        'dvm_write.write_ind(\n' +
        '    pos_file_path = ' + 'r\'' + str(pos_file_path) + '\',' + '\n' +
        '    elmt_ind_file_dir = ' + 'r\'' + str(elmt_ind_file_dir) + '\')\n' +
        '########################\n'
        )
    return 0

def write_ie(dvm_otput_file_path):
    '''
    Interatomic energy between the atoms and their nearest neighbor atoms.
    This module has been tested for the source_23oct05 version of the DVM program
    dvm_otput_file_path: the *.otput file of the DVM output
    '''
    import os
    import numpy as np
    from .. import funcs
    from .. import convert
    from ..vasp import vasp_read
    from ..vasp import vasp_analyze
    from . import dvm_read
    from .. import default_params

    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    output_dir = os.path.join(os.getcwd(), defaults_dict['output_dir_name'])
    funcs.mkdir(output_dir)

    dvm_otput_file_path = os.path.abspath(dvm_otput_file_path)
    # designate the working directory
    workdir, dvm_otput_file = funcs.file_path_name(dvm_otput_file_path)

    dvm_incar_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '.incar')
    convert.dvmincar2poscar(dvm_incar_file_path)
    dvmincar2poscar_poscar_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_dvmincar2poscar.vasp')
    poscar_dict = vasp_read.read_poscar(dvmincar2poscar_poscar_file_path)
    atom_name_list = poscar_dict['atomname_list']
    atom_indx_arr = poscar_dict['atom_indx_arr'] 
    n_atoms = poscar_dict['n_atoms']
    added_atom_data_arr = poscar_dict['added_atom_data']
    dvm_otput_dict = dvm_read.read_otput(dvm_otput_file_path)

    ie_au_arr = None
    ie_au_up_arr = None
    ie_au_dw_arr = None
    if dvm_otput_dict['spin'] == 0:
        ie_au_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_arr[i_atom, j_atom] = dvm_otput_dict['ie_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
    if dvm_otput_dict['spin'] == 1:
        ie_au_up_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_up_arr.shape = n_atoms, n_atoms
        ie_au_dw_arr = np.array([None] * n_atoms * n_atoms)
        ie_au_dw_arr.shape = n_atoms, n_atoms
        for i_atom in range(0, n_atoms):
            for j_atom in range(0, n_atoms):
                ie_au_up_arr[i_atom, j_atom] = dvm_otput_dict['ie_up_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]
                ie_au_dw_arr[i_atom, j_atom] = dvm_otput_dict['ie_dw_arr'][int(added_atom_data_arr[i_atom, 3]) - 1, int(added_atom_data_arr[j_atom, 3]) - 1]

    # the output indices based on the atom names
    # write the data into files
    ie_au_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_au_all_atoms.txt')
    ie_ev_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_ev_all_atoms.txt')
    ie_au_file_str = ''
    ie_ev_file_str = ''
    
    for i_atom in range(0, n_atoms):
        i_atom_str = atom_name_list[i_atom] + ' (' + str(added_atom_data_arr[i_atom, 3]) + ')'
        atom_name_str = ', '.join([str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')' + ' ' * (13 - len(str(x) + ' (' + str(added_atom_data_arr[atom_name_list.index(x), 3]) + ')')) for x in atom_name_list]) + '\n'

        if dvm_otput_dict['spin'] == 0:
            temp_au_arr = ie_au_arr[i_atom,:]
            temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
            ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
            ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
            ie_au_file_str = ie_au_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                ie_au_str
                )
            ie_ev_file_str = ie_ev_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                ie_ev_str
                )
        if dvm_otput_dict['spin'] == 1:
            temp_au_up_arr = ie_au_up_arr[i_atom,:]
            temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
            temp_au_dw_arr = ie_au_dw_arr[i_atom,:]
            temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
            ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
            ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
            ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
            ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
            ie_au_file_str = ie_au_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                ie_au_up_str +
                ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                ie_au_dw_str
                )
            ie_ev_file_str = ie_ev_file_str + (
                i_atom_str + ' ' * (13 - len(i_atom_str)) + ', ' + 
                atom_name_str +
                ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                ie_ev_up_str +
                ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                ie_ev_dw_str
                )
    with open(ie_au_file_path, 'w') as f_ie_au, open(ie_ev_file_path, 'w') as f_ie_ev:
        f_ie_au.write(ie_au_file_str)
        f_ie_ev.write(ie_ev_file_str)


    # the output indices based on the DVM atom indices
    # write the data into files
    ie_au_dvm_indx_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_au_all_atoms_dvm_index.txt')
    ie_ev_dvm_indx_file_path = os.path.join(workdir, dvm_otput_file[0:-6] + '_ie_ev_all_atoms_dvm_index.txt')
    ie_au_dvm_indx_file_str = ''
    ie_ev_dvm_indx_file_str = ''
    for i_dvm_atom_indx in range(1, n_atoms + 1):
        #i_atom = int(list(added_atom_data_arr[:, 3]).index(str(i_dvm_atom_indx)))
        i_atom = int(np.argwhere(added_atom_data_arr[:, 3] == str(i_dvm_atom_indx)))
        i_dvm_indx_str = str(i_dvm_atom_indx) + ' (' + atom_name_list[i_atom] + ')'
        dvm_atom_indx_str = ', '.join([str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')' + ' ' * (13 - len(str(x) + ' (' + atom_name_list[int(np.argwhere(added_atom_data_arr[:, 3] == str(x)))] + ')')) for x in list(range(1, n_atoms + 1))]) + '\n'

        if dvm_otput_dict['spin'] == 0:
            temp_au_arr = dvm_otput_dict['ie_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_arr = temp_au_arr * convert.unitconvert('a.u.','eV')
            ie_au_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_arr]) + '\n'
            ie_ev_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_arr]) + '\n'
            ie_au_dvm_indx_file_str = ie_au_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (a.u.)' + ' ' * (13 - len(' IE (a.u.)')) + ', ' +
                ie_au_str
                )
            ie_ev_dvm_indx_file_str = ie_ev_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (eV)'  + ' ' * (13 - len(' IE (eV)')) + ', ' +
                ie_ev_str
                )
        if dvm_otput_dict['spin'] == 1:
            temp_au_up_arr = dvm_otput_dict['ie_up_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_up_arr = temp_au_up_arr * convert.unitconvert('a.u.','eV')
            temp_au_dw_arr = dvm_otput_dict['ie_dw_arr'][i_dvm_atom_indx -1 , :]
            temp_ev_dw_arr = temp_au_dw_arr * convert.unitconvert('a.u.','eV')
            ie_au_up_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_up_arr]) + '\n'
            ie_ev_up_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_up_arr]) + '\n'
            ie_au_dw_str = ', '.join([str(x) + ' ' * (13 - len(str(x))) for x in temp_au_dw_arr]) + '\n'
            ie_ev_dw_str = ', '.join(['{:.4f}'.format(x) + ' ' * (13 - len('{:.4f}'.format(x))) for x in temp_ev_dw_arr]) + '\n'
            ie_au_dvm_indx_file_str = ie_au_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (a.u.) up' + ' ' * (13 - len(' ' * len(' IE (a.u.) up'))) + ', ' +
                ie_au_up_str +
                ' IE (a.u.) dw' + ' ' * (13 - len(' ' * len(' IE (a.u.) dw'))) + ', ' +
                ie_au_dw_str
                )
            ie_ev_dvm_indx_file_str = ie_ev_dvm_indx_file_str + (
                i_dvm_indx_str + ' ' * (13 - len(i_dvm_indx_str)) + ', ' + 
                dvm_atom_indx_str +
                ' IE (eV) up' + ' ' * (13 - len(' ' * len(' IE (eV) up'))) + ', ' +
                ie_ev_up_str +
                ' IE (eV) dw' + ' ' * (13 - len(' ' * len(' IE (eV) dw'))) + ', ' +
                ie_ev_dw_str
                )
    with open(ie_au_dvm_indx_file_path, 'w') as f_ie_au_dvm_indx, open(ie_ev_dvm_indx_file_path, 'w') as f_ie_ev_dvm_indx:
        f_ie_au_dvm_indx.write(ie_au_dvm_indx_file_str)
        f_ie_ev_dvm_indx.write(ie_ev_dvm_indx_file_str)

    funcs.write_log(
        logfile,
        'dvm_write.write_ie(\n' + 
        '    dvm_otput_file_path = ' + 'r\'' + str(dvm_otput_file_path) + '\')\n' +
        '#######################\n'
        )
    return ie_au_arr, ie_au_up_arr, ie_au_dw_arr

def write_tex_ie_nn(ie_nn_file_path):
    '''
    write the .tex file of the IE result.
    the spin restricted and spin polarized situations are considered
    ie_nn_file_path: the path for the IE result, it can either be *_ie_ev_nn.txt or *_ie_eu_nn.txt
    '''
    import os
    from .. import funcs
    from . import dvm_default
    from .. import default_params

    defaults_dict = default_params.default_params()
    logfile = defaults_dict['logfile']
    ie_nn_file_path = os.path.abspath(ie_nn_file_path)
    workdir, ie_nn_file = funcs.file_path_name(ie_nn_file_path)
    if funcs.file_status(ie_nn_file_path) != 1:
        quit()
    with open(ie_nn_file_path, 'r') as f:
        lines = f.readlines()
        temp = funcs.split_line(lines[1],',')[0]
        if 'up' in temp:
            # spin polarized
            spin = 1
        else:
            # spin restricted
            spin = 0
        if 'eV' in temp:
            unit_tex_str = 'eV'
            unit_file_str = 'ev'
        elif 'a.u.' in temp:
            unit_tex_str = 'a.u.'
            unit_file_str = 'au'
    ie_nn_tex_file_path = os.path.join(workdir, 'ie_nn_' + unit_file_str + '.tex')
    ie_nn_tex_str = ''
    ie_nn_tex_str = ie_nn_tex_str + (
        r'\documentclass[12pt]{article}' + '\n' +
        r'\usepackage{hyperref}' + '\n' +
        r'\usepackage{longtable}' + '\n' +
        r'\title{Interatomic energy of the nearest neighbor atoms}' + '\n' +
        r'\date{}' + '\n' +
        r'\author{}' + '\n' +
        r'\begin{document}' + '\n' +
        r'\maketitle' + '\n' +
        r'\section{Interatomic energy}' + '\n')
    if spin == 0:
        ie_nn_tex_str = ie_nn_tex_str + (
        r'\begin{longtable}{lll}' + '\n' +
        r'\caption{IE (' + unit_tex_str + r')}\\' + '\n' +
        r'\hline' + '\n' +
        r'atom (i) & atom (j) & IE (' + unit_tex_str + r') \\' + '\n' +
        r'\hline' + '\n')
    elif spin == 1:
        ie_nn_tex_str = ie_nn_tex_str + (
        r'\begin{longtable}{llll}' + '\n' +
        r'\caption{IE (' + unit_tex_str + r')}\\' + '\n' +
        r'\hline\n' +
        r'atom (i) & atom (j) & IE (' + unit_tex_str + ')-up & IE (' + unit_tex_str + r')-dw \\' + '\n' +
        r'\hline' + '\n')
        
    with open(ie_nn_file_path, 'r') as f:
        lines = f.readlines()
    for i_line in range(0, len(lines)):
        if spin == 0 and i_line%2 == 0:
            num_col = len(funcs.split_line(lines[i_line],','))
            i_atom_name = str(funcs.split_line(lines[i_line],',')[0])
            j_atom_name_list = [str(x) for x in funcs.split_line(lines[i_line],',')[1:]]
            ie_list = [float(x) for x in funcs.split_line(lines[i_line + 1],',')[1:]]
            for indx in range(0, len(j_atom_name_list)):
                ie_nn_tex_str = ie_nn_tex_str + (
                    i_atom_name + ' ' * (13 - len(i_atom_name)) + '&' +
                    j_atom_name_list[indx] + ' ' * (13 - len(j_atom_name_list[indx])) + '&' +
                    '{:.4f}'.format(ie_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_list[indx]))) + r'\\' + '\n')
        elif spin == 1 and i_line%3 == 0:
            num_col = len(funcs.split_line(lines[i_line],','))
            i_atom_name = str(funcs.split_line(lines[i_line],',')[0])
            j_atom_name_list = [str(x) for x in funcs.split_line(lines[i_line],',')[1:]]
            ie_up_list = [float(x) for x in funcs.split_line(lines[i_line + 1],',')[1:]]
            ie_dw_list = [float(x) for x in funcs.split_line(lines[i_line + 2],',')[1:]]
            for indx in range(0, len(j_atom_name_list)):
                ie_nn_tex_str = ie_nn_tex_str + (
                    i_atom_name + ' ' * (13 - len(i_atom_name)) + '&' +
                    j_atom_name_list[indx] + ' ' * (13 - len(j_atom_name_list[indx])) + '&' +
                    '{:.4f}'.format(ie_up_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_up_list[indx]))) + '&' +
                    '{:.4f}'.format(ie_dw_list[indx]) + ' ' * (13 - len('{:.4f}'.format(ie_dw_list[indx]))) + r'\\' + '\n')
    ie_nn_tex_str = ie_nn_tex_str + (
        r'\hline' + '\n' +
        r'\end{longtable}' + '\n' +
        r'\end{document}')
    with open(ie_nn_tex_file_path, 'w') as f_tex:
        f_tex.write(ie_nn_tex_str)
    return 0
